#define  _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
#include <cstring>

using namespace std;

// 如果要次数最少，每个灯的只能点一次，点两次相当于没点。
// 点每个位置的灯没有先后顺序，所以可以从第一行按顺序点灯
// 先对第一行的五个灯做出选择，再根据第一行的灯的状态来点第二行的灯，以此类推
// 统计点灯次数最少的次数
// 每次点灯，灯暗时状态变为亮，灯亮时状态转为暗


// 用g数组记录灯阵的状态
char g[10][10];
// 灯的初识状态不能改变，所以应该再开一个数组，在这个数组上对灯阵进行修改
char backup[10][10];

// 定义两个数组分别代表行和列，每个数组有五个元素，分别表示原位置和上下左右
// 注：这里的x和y并非表示数学中的坐标，x表示行，y表示列
char dx[] = { 0,-1,1,0,0 }, dy[] = { 0,0,0,-1,1 };

void turn(int x, int y)
{
    // a表示行，b表示列
    // 用for循环遍历原位置，以及上下左右四个位置
    // 若这个位置上为0变为1，为1变为0
    for (int i = 0; i < 5; i++)
    {
        int a = x + dx[i], b = y + dy[i];
        // 这里使用异或操作符
        // 0和1的ASCII值分别为48和49
        // 根据异或的概念48^1为49，而49^1为48
        if (a >= 0 && a <= 4 && b >= 0 && b <= 4)
        {
            backup[a][b] ^= 1;
        }
    }
}

// 在work函数中对灯阵进行判断
int work()
{
    // 定义一个应该返回的值，这个返回值要大于6，与后面点灯的次数作判断
    int ans = 100;

    // 0到31有5个正在改变的二进制位，每个二进制位的0和1表示第一行的灯的状态
    // 且每个二进制位对应一个灯的位置
    for (int k = 0; k < 1 << 5; k++)
    {
        int num = 0; // 记录每个方法点灯的次数
        memcpy(backup, g, sizeof(g)); // 将灯的初识状态拷贝给新数组

        // 对第一行进行点灯，k不同点灯的情况就不同
        for (int j = 0; j < 5; j++)
        {
            // 移位操作符的优先级大于按位与操作符，将k右移j位再与上1可判断k的哪一位有1
            if ((k >> j & 1) == 1)
            {
                // 如果这个位上为1，进行点灯，点灯的次数加1并且进入点灯函数
                num++;
                // 0表示为第一行，j表示为这行第几个灯
                turn(0, j);
            }
        }

        // 从第一行开始依此向下，遍历前四行
        // 在每行中，如果这行中某个位置灯为暗，对这个位置正下方进行点灯
        for (int i = 0; i < 4; i++)
        {
            // 遍历这行中每个位置
            for (int j = 0; j < 5; j++)
            {
                // 如果这个位置灯暗，点正下方位置的灯，并且次数加一
                if (backup[i][j] == '0')
                {
                    num++;
                    turn(i + 1, j);
                }
            }
        }

        // 上面的操作可以保证前四行的灯都在亮着，此时判断最后一行是否全亮即可

        // 先假设最后一行全亮
        bool is_successful = true;

        for (int j = 0; j < 5; j++)
        {
            if (backup[4][j] == '0')
            {
                // 如果有暗的，赋值为false
                is_successful = false;
            }
        }

        // 如果都在亮着，进行赋值
        if (is_successful == true)
        {
            ans = min(ans, num);
        }
    }

    return ans <= 6 ? ans : -1;
}

int main()
{
    // 定义灯阵的数量
    int n;
    scanf("%d", &n);
    // 用while循环输入每个灯阵
    while (n--)
    {
        // 只用一个for循环就可以输出一个灯阵
        // 原因是将每行看成字符串，一次就可以输入一行，用for循环输入五行即可
        for (int i = 0; i < 5; i++)
        {
            scanf("%s", g[i]);
        }
        // 在work函数中对这个灯阵进行判断，并用ret记录返回值。
        int ret = work();
        printf("%d\n", ret);
    }
}
